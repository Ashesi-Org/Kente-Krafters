<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fabric Customizer</title>
  <style>
    
    /* Style for the color picker */
    #colorPicker {
      position: absolute;
      top: 10px;
      left: 420px; /* Adjust the left position as needed */
      width: 40px; /* Set the width and height to create a circular color picker */
      height: 40px;
      border: none;
      outline: none;
      padding: 0;
      margin: 0;
    }
    #addToCartButton {
      width: 100px;
      height: 40px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }

    html{
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    body{
      display: flex;
      flex-direction: column;
      width: 100%;
    }
  </style>
</head>

  
<body>
  <div class="wrapper">
    <input type="color" id="colorPicker" value="#000000">
  </div>
  <div class="wrapper">
  <canvas id="myCanvas" width="600" height="600"></canvas></div>
  <button id="addToCartButton">Add to Cart</button>

  
  <script>
    let selected_pixel = '';
    let finalDataDict = {};
    
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');  
    
    colorPicker.addEventListener('input', function () {
      const selectedColor = this.value;
      // alert(`Selected Color: ${selectedColor}`)
      recolorAll(selected_pixel, selectedColor);
    });

    canvas.addEventListener('click', function (event) {
      const x = event.clientX - canvas.getBoundingClientRect().left;
      const y = event.clientY - canvas.getBoundingClientRect().top;
      const clickedCoordinates = [y, x];
      selected_pixel = clickedCoordinates;
    });

    const addToCartButton = document.getElementById('addToCartButton');
    addToCartButton.addEventListener('click', addToCart);

    
    //A function to draw a textile
    function drawTextile(colordict){
      for (const coord in colordict) {
          const squareSize = 1;
          if (finalDataDict.hasOwnProperty(coord)) {
              const color = finalDataDict[coord];
              const [x, y] = coord.split(',').map(Number);
              ctx.fillStyle = color;
              ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
              ctx.save();
            }
        }
    }
    
    //Function to convert rgb color to hex value
    function rgbToHex(r, g, b) {
        const toHex = (value) => {
            const hex = value.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        };
        const redHex = toHex(r);
        const greenHex = toHex(g);
        const blueHex = toHex(b);
        return "#" + redHex + greenHex + blueHex;
    }

    
    // A function to recolor the textile
    function recolorAll(coordinate, selectedColor) {
        oldColor = finalDataDict[coordinate];
        console.log("This is old color" + oldColor);
        for (const key in finalDataDict) {
            if (finalDataDict.hasOwnProperty(key)) {
                if (finalDataDict[key] === oldColor) {
                    finalDataDict[key] = selectedColor;
                }
            }
        }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTextile(finalDataDict);
    }

    //Function to save customization as image and store 
    function addToCart() {
      const imageDataURL = canvas.toDataURL('image/png');
      // Create a temporary anchor element
      const downloadLink = document.createElement('a');
      downloadLink.href = imageDataURL;
      downloadLink.download = 'canvas_image.png';
      // Append the anchor element to the document
      document.body.appendChild(downloadLink);
      // Trigger a click on the anchor element to start the download
      downloadLink.click();
      // Remove the anchor element from the document
      document.body.removeChild(downloadLink);
    }

    //Fetching and decoding the textile template
    fetch('/getTextileTemplate')
    .then(response => response.json())
    .then(newDataDictionary => {
      // Assessing the textile data
      Object.keys(newDataDictionary).forEach(rgb => {
        const color = rgb.split(',').map(Number);
        const points = newDataDictionary[rgb];
        points.forEach(point => {
          const [x, y] = point;
          const hexCode = rgbToHex(color[0], color[1], color[2]);
          const coordinatesString = `${y},${x}`;
          finalDataDict[coordinatesString] = hexCode;
        });
      });
      drawTextile(finalDataDict);
    })
    .catch(error => console.error('Error fetching data:', error));

    
  </script>
</body>
</html>
